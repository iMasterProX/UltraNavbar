package com.minsoo.ultranavbar.ui

import android.content.res.Configuration
import android.graphics.Color
import android.os.Bundle
import android.view.KeyEvent
import android.view.View
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.google.android.material.button.MaterialButton
import com.google.android.material.card.MaterialCardView
import com.minsoo.ultranavbar.R
import com.minsoo.ultranavbar.ui.view.DrawingCanvasView

/**
 * 펜 버튼 기능 테스트를 위한 캔버스 Activity
 *
 * 사용자가 펜 버튼 A/B에 설정한 기능이 실제로 작동하는지 테스트할 수 있습니다.
 */
class PenTestCanvasActivity : AppCompatActivity() {

    private lateinit var canvasView: DrawingCanvasView
    private var isEraserMode = false

    // input keycombination에서 수정자 키 상태 추적 (키가 순차적으로 전송됨)
    private var isCtrlDown = false
    private var isShiftDown = false

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_pen_test_canvas)

        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        title = getString(R.string.pen_test_canvas_title)

        canvasView = findViewById(R.id.drawingCanvas)

        // 다크 모드 확인하여 색상 설정
        val isDarkMode = (resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK) == Configuration.UI_MODE_NIGHT_YES
        val drawColor = if (isDarkMode) Color.WHITE else Color.BLACK
        canvasView.setPaintColor(drawColor)

        setupButtons()
        showInstructions()
    }

    private fun setupButtons() {
        findViewById<MaterialButton>(R.id.btnUndo)?.setOnClickListener {
            canvasView.undo()
        }

        findViewById<MaterialButton>(R.id.btnRedo)?.setOnClickListener {
            canvasView.redo()
        }

        findViewById<MaterialButton>(R.id.btnEraser)?.setOnClickListener {
            toggleEraser()
        }

        findViewById<MaterialButton>(R.id.btnClear)?.setOnClickListener {
            canvasView.clear()
        }

        findViewById<MaterialButton>(R.id.btnBrushUp)?.setOnClickListener {
            canvasView.increaseBrushSize()
            showBrushSize()
        }

        findViewById<MaterialButton>(R.id.btnBrushDown)?.setOnClickListener {
            canvasView.decreaseBrushSize()
            showBrushSize()
        }
    }

    private fun toggleEraser() {
        isEraserMode = !isEraserMode
        canvasView.setEraserMode(isEraserMode)

        val btn = findViewById<MaterialButton>(R.id.btnEraser)
        if (isEraserMode) {
            btn?.text = getString(R.string.pen_test_brush_mode)
        } else {
            btn?.text = getString(R.string.pen_test_eraser_mode)
        }
    }

    private fun showBrushSize() {
        val size = canvasView.getCurrentBrushSize()
        Toast.makeText(this, getString(R.string.pen_test_brush_size, size), Toast.LENGTH_SHORT).show()
    }

    private fun showInstructions() {
        val card = findViewById<MaterialCardView>(R.id.cardInstructions)
        val btnDismiss = findViewById<MaterialButton>(R.id.btnDismissInstructions)

        btnDismiss?.setOnClickListener {
            card?.visibility = View.GONE
        }
    }

    override fun onSupportNavigateUp(): Boolean {
        finish()
        return true
    }

    override fun onPause() {
        super.onPause()
        // TooltipPopup이 열려있으면 WindowLeaked 발생할 수 있으므로
        // 모든 버튼의 tooltip을 해제
        dismissAllTooltips()
    }

    override fun onDestroy() {
        dismissAllTooltips()
        super.onDestroy()
    }

    private fun dismissAllTooltips() {
        // 모든 버튼에서 pending tooltip 취소
        listOf(
            R.id.btnUndo, R.id.btnRedo, R.id.btnEraser,
            R.id.btnClear, R.id.btnBrushUp, R.id.btnBrushDown,
            R.id.btnDismissInstructions
        ).forEach { id ->
            findViewById<View>(id)?.apply {
                // Handler에 예약된 tooltip 표시 취소
                handler?.removeCallbacksAndMessages(null)
                // 이미 표시된 tooltip 숨기기 (API 26+)
                if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
                    tooltipText = null
                }
            }
        }
        // DecorView의 모든 pending callback 제거
        window?.decorView?.handler?.removeCallbacksAndMessages(null)
    }

    // 외부에서 Undo/Redo/Eraser 기능 호출 (펜 버튼 이벤트용)
    fun performUndo() {
        runOnUiThread {
            canvasView.undo()
        }
    }

    fun performRedo() {
        runOnUiThread {
            canvasView.redo()
        }
    }

    fun performEraserToggle() {
        runOnUiThread {
            toggleEraser()
        }
    }

    fun performBrushSizeIncrease() {
        runOnUiThread {
            canvasView.increaseBrushSize()
            showBrushSize()
        }
    }

    fun performBrushSizeDecrease() {
        runOnUiThread {
            canvasView.decreaseBrushSize()
            showBrushSize()
        }
    }

    /**
     * 키보드 단축키 처리
     * Bridge Activity에서 주입된 키 이벤트를 여기서 처리
     *
     * 참고: input keycombination 명령은 키를 순차적으로 전송하므로,
     * Ctrl+Z를 보내면 Ctrl DOWN → Z DOWN → Z UP → Ctrl UP 순으로 전달됨.
     * 이 때 Z 이벤트에서 isCtrlPressed가 false일 수 있어서 수동 추적 필요.
     */
    override fun onKeyDown(keyCode: Int, event: KeyEvent?): Boolean {
        if (event == null) return super.onKeyDown(keyCode, event)

        // 수정자 키 상태 추적 (input keycombination 대응)
        when (keyCode) {
            KeyEvent.KEYCODE_CTRL_LEFT, KeyEvent.KEYCODE_CTRL_RIGHT -> {
                isCtrlDown = true
                android.util.Log.d("PenTestCanvas", "onKeyDown: Ctrl pressed, isCtrlDown=$isCtrlDown")
                return false // 수정자 키는 consume하지 않음
            }
            KeyEvent.KEYCODE_SHIFT_LEFT, KeyEvent.KEYCODE_SHIFT_RIGHT -> {
                isShiftDown = true
                android.util.Log.d("PenTestCanvas", "onKeyDown: Shift pressed, isShiftDown=$isShiftDown")
                return false
            }
        }

        // 실제 Ctrl 상태 확인 (시스템 상태 또는 수동 추적 상태)
        val ctrlPressed = event.isCtrlPressed || isCtrlDown
        val shiftPressed = event.isShiftPressed || isShiftDown

        android.util.Log.d("PenTestCanvas", "onKeyDown: keyCode=$keyCode, ctrl=$ctrlPressed, shift=$shiftPressed (system: ctrl=${event.isCtrlPressed}, shift=${event.isShiftPressed})")

        // Ctrl 조합키
        if (ctrlPressed) {
            when (keyCode) {
                KeyEvent.KEYCODE_Z -> {
                    if (shiftPressed) {
                        // Ctrl+Shift+Z = Redo
                        android.util.Log.d("PenTestCanvas", "Executing Redo (Ctrl+Shift+Z)")
                        canvasView.redo()
                    } else {
                        // Ctrl+Z = Undo
                        android.util.Log.d("PenTestCanvas", "Executing Undo (Ctrl+Z)")
                        canvasView.undo()
                    }
                    resetModifierState()
                    return true
                }
                KeyEvent.KEYCODE_Y -> {
                    // Ctrl+Y = Redo
                    android.util.Log.d("PenTestCanvas", "Executing Redo (Ctrl+Y)")
                    canvasView.redo()
                    resetModifierState()
                    return true
                }
            }
        }

        // 단일 키
        when (keyCode) {
            KeyEvent.KEYCODE_E -> {
                // E = 지우개 토글
                toggleEraser()
                return true
            }
            KeyEvent.KEYCODE_PLUS, KeyEvent.KEYCODE_EQUALS -> {
                // + = 브러시 크기 증가
                if (ctrlPressed || shiftPressed) {
                    canvasView.increaseBrushSize()
                    showBrushSize()
                    resetModifierState()
                    return true
                }
            }
            KeyEvent.KEYCODE_MINUS -> {
                // - = 브러시 크기 감소
                if (ctrlPressed) {
                    canvasView.decreaseBrushSize()
                    showBrushSize()
                    resetModifierState()
                    return true
                }
            }
            KeyEvent.KEYCODE_LEFT_BRACKET -> {
                // [ = 브러시 크기 감소
                canvasView.decreaseBrushSize()
                showBrushSize()
                return true
            }
            KeyEvent.KEYCODE_RIGHT_BRACKET -> {
                // ] = 브러시 크기 증가
                canvasView.increaseBrushSize()
                showBrushSize()
                return true
            }
        }

        return super.onKeyDown(keyCode, event)
    }

    override fun onKeyUp(keyCode: Int, event: KeyEvent?): Boolean {
        // 수정자 키 해제 추적
        when (keyCode) {
            KeyEvent.KEYCODE_CTRL_LEFT, KeyEvent.KEYCODE_CTRL_RIGHT -> {
                isCtrlDown = false
                android.util.Log.d("PenTestCanvas", "onKeyUp: Ctrl released")
            }
            KeyEvent.KEYCODE_SHIFT_LEFT, KeyEvent.KEYCODE_SHIFT_RIGHT -> {
                isShiftDown = false
                android.util.Log.d("PenTestCanvas", "onKeyUp: Shift released")
            }
        }
        return super.onKeyUp(keyCode, event)
    }

    private fun resetModifierState() {
        isCtrlDown = false
        isShiftDown = false
    }
}
